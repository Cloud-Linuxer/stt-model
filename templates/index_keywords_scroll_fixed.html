<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 STT + AI 키워드 추출</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2rem;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .status {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .status-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .status-item.active {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        #recordButton {
            background: white;
            color: #667eea;
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #recordButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        #recordButton.recording {
            background: #ff4444;
            color: white;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .audio-visualizer {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 40px;
            gap: 3px;
            margin: 20px 0;
        }

        .audio-bar {
            width: 4px;
            background: white;
            border-radius: 2px;
            transition: height 0.1s ease;
            opacity: 0.8;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            margin-top: 10px;
            font-size: 0.9rem;
        }

        .stats span {
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            gap: 20px;
            padding: 30px;
            min-height: 500px;
        }

        .transcription-panel, .keywords-panel {
            flex: 1;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .panel-title {
            font-size: 1.2rem;
            color: #333;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .clear-btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .clear-btn:hover {
            background: #ff5252;
            transform: translateY(-1px);
        }

        #transcriptionText {
            flex: 1;
            overflow-y: auto;
            max-height: 400px;
            padding: 10px;
            background: white;
            border-radius: 10px;
        }

        .transcript-item {
            padding: 12px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #667eea10 0%, #764ba210 100%);
            border-left: 4px solid #667eea;
            border-radius: 8px;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .transcript-time {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 5px;
        }

        .transcript-text {
            color: #333;
            line-height: 1.5;
        }

        #keywordsContainer {
            flex: 1;
            overflow-y: auto;
            max-height: 400px;
            padding: 10px;
            background: white;
            border-radius: 10px;
        }

        .keyword-item {
            display: inline-flex;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 20px;
            animation: popIn 0.3s ease;
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.3);
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .keyword-text {
            font-weight: 500;
            margin-right: 8px;
        }

        .keyword-score {
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.85rem;
        }

        .keyword-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 5px;
        }

        .no-keywords {
            text-align: center;
            color: #999;
            padding: 40px;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .status {
                flex-direction: column;
                align-items: center;
            }
        }

        .debug-panel {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            margin: 20px 30px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            max-height: 150px;
            overflow-y: auto;
        }

        .debug-log {
            margin-bottom: 5px;
            padding: 3px 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        /* 스크롤바 스타일 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6b4299 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎤 실시간 STT + 🤖 AI 키워드 추출</h1>
            <div class="status">
                <div class="status-item" id="wsStatus">연결 대기중...</div>
                <div class="status-item" id="deviceStatus">GPU 대기중...</div>
                <div class="status-item" id="llmStatus">LLM 대기중...</div>
            </div>
            <button id="recordButton">🎤 녹음 시작</button>
            <div class="audio-visualizer" id="audioVisualizer"></div>
            <div class="stats">
                <span>📝 텍스트: <span id="textCount">0</span>개</span>
                <span>🔑 키워드: <span id="keywordCount">0</span>개</span>
                <span>⏱️ 녹음 시간: <span id="recordTime">00:00</span></span>
                <span>📊 오디오 패킷: <span id="packetCount">0</span></span>
            </div>
        </div>

        <div class="main-content">
            <div class="transcription-panel">
                <h2 class="panel-title">
                    📝 음성 인식 결과 (누적)
                    <button class="clear-btn" onclick="clearTranscripts()">초기화</button>
                </h2>
                <div id="transcriptionText">
                    <div class="no-keywords">녹음 버튼을 눌러 시작하세요...</div>
                </div>
            </div>
            <div class="keywords-panel">
                <h2 class="panel-title">
                    🔑 추출된 키워드 (누적)
                    <button class="clear-btn" onclick="clearKeywords()">초기화</button>
                </h2>
                <div id="keywordsContainer">
                    <div class="no-keywords">키워드가 여기에 표시됩니다</div>
                </div>
            </div>
        </div>

        <div class="debug-panel" id="debugPanel">
            <div class="debug-log">Debug logs will appear here...</div>
        </div>
    </div>

    <script>
        // 페이지 로드 완료 후 실행
        document.addEventListener('DOMContentLoaded', function() {

        let websocket;
        let isRecording = false;
        let audioContext;
        let source;
        let processor;
        let recordingStartTime = null;
        let recordingTimer = null;
        let transcriptCount = 0;
        let keywordMap = new Map();
        let packetsSent = 0;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let reconnectDelay = 1000; // 초기 재연결 지연 시간 (1초)
        let reconnectTimeout = null;
        let isIntentionalClose = false; // 의도적인 종료 여부

        const recordButton = document.getElementById('recordButton');
        const transcriptionText = document.getElementById('transcriptionText');
        const keywordsContainer = document.getElementById('keywordsContainer');
        const wsStatus = document.getElementById('wsStatus');
        const deviceStatus = document.getElementById('deviceStatus');
        const llmStatus = document.getElementById('llmStatus');
        const audioVisualizer = document.getElementById('audioVisualizer');
        const textCount = document.getElementById('textCount');
        const keywordCount = document.getElementById('keywordCount');
        const recordTime = document.getElementById('recordTime');
        const packetCount = document.getElementById('packetCount');
        const debugPanel = document.getElementById('debugPanel');

        // 디버그 로그
        function debugLog(message) {
            const time = new Date().toLocaleTimeString('ko-KR', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
            const log = document.createElement('div');
            log.className = 'debug-log';
            log.textContent = `[${time}] ${message}`;
            debugPanel.appendChild(log);
            debugPanel.scrollTop = debugPanel.scrollHeight;
            console.log(message);
        }

        // 오디오 시각화 바 생성
        for (let i = 0; i < 20; i++) {
            const bar = document.createElement('div');
            bar.className = 'audio-bar';
            bar.style.height = '5px';
            audioVisualizer.appendChild(bar);
        }

        // 녹음 시간 업데이트
        function updateRecordTime() {
            if (recordingStartTime) {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                recordTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // WebSocket 연결 관리 개선
        function connectWebSocket() {
            // 기존 재연결 타이머 취소
            if (reconnectTimeout) {
                clearTimeout(reconnectTimeout);
                reconnectTimeout = null;
            }

            // 최대 재연결 시도 횟수 초과 시
            if (reconnectAttempts >= maxReconnectAttempts) {
                debugLog(`Maximum reconnection attempts (${maxReconnectAttempts}) reached. Please refresh the page.`);
                wsStatus.textContent = '❌ 재연결 실패';
                wsStatus.classList.remove('active');
                return;
            }

            const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
            const wsUrl = `${protocol}://${window.location.host}/ws`;

            if (reconnectAttempts > 0) {
                debugLog(`Reconnection attempt ${reconnectAttempts}/${maxReconnectAttempts} to ${wsUrl}`);
                wsStatus.textContent = `🔄 재연결 시도 (${reconnectAttempts}/${maxReconnectAttempts})...`;
            } else {
                debugLog(`Connecting to WebSocket: ${wsUrl}`);
                wsStatus.textContent = '🔄 연결 중...';
            }

            try {
                websocket = new WebSocket(wsUrl);

                websocket.onopen = () => {
                    debugLog('WebSocket connected successfully');
                    wsStatus.textContent = '✅ 연결됨';
                    wsStatus.classList.add('active');

                    // 재연결 성공 시 카운터 초기화
                    reconnectAttempts = 0;
                    reconnectDelay = 1000;

                    // 설정 메시지 전송
                    websocket.send(JSON.stringify({
                        type: 'config',
                        language: 'ko'
                    }));
                    debugLog('Sent config message');
                };

                websocket.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    debugLog(`Received message type: ${data.type}`);

                    if (data.type === 'transcription') {
                        if (data.text) {
                            debugLog(`Transcription received: ${data.text}`);
                            addTranscript(data.text);
                        }
                        if (data.keywords && data.keywords.length > 0) {
                            debugLog(`Keywords received: ${data.keywords.length} keywords`);
                            addKeywords(data.keywords);
                            llmStatus.textContent = '✅ LLM 활성';
                            llmStatus.classList.add('active');
                        }
                        if (data.device === 'cuda') {
                            deviceStatus.textContent = '✅ GPU 활성';
                            deviceStatus.classList.add('active');
                        }
                    }
                };

                websocket.onerror = (error) => {
                    debugLog(`WebSocket error: ${error}`);
                    wsStatus.textContent = '❌ 연결 오류';
                    wsStatus.classList.remove('active');
                };

                websocket.onclose = (event) => {
                    debugLog(`WebSocket closed. Code: ${event.code}, Reason: ${event.reason}`);
                    wsStatus.textContent = '❌ 연결 끊김';
                    wsStatus.classList.remove('active');

                    // 의도적인 종료가 아니고, 재연결 시도 횟수가 남아있으면 재연결
                    if (!isIntentionalClose && reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;

                        // 지수 백오프로 재연결 지연 시간 증가 (최대 30초)
                        const currentDelay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts - 1), 30000);
                        debugLog(`Scheduling reconnection in ${currentDelay/1000} seconds...`);

                        wsStatus.textContent = `⏱️ ${Math.round(currentDelay/1000)}초 후 재연결...`;

                        reconnectTimeout = setTimeout(() => {
                            connectWebSocket();
                        }, currentDelay);
                    }
                };

            } catch (error) {
                debugLog(`Failed to create WebSocket: ${error}`);
                wsStatus.textContent = '❌ 연결 실패';
                wsStatus.classList.remove('active');

                // 연결 생성 실패 시에도 재연결 시도
                if (!isIntentionalClose && reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    const currentDelay = Math.min(reconnectDelay * Math.pow(1.5, reconnectAttempts - 1), 30000);

                    reconnectTimeout = setTimeout(() => {
                        connectWebSocket();
                    }, currentDelay);
                }
            }
        }

        // 수동 재연결 함수
        function reconnectWebSocket() {
            debugLog('Manual reconnection requested');
            isIntentionalClose = false;
            reconnectAttempts = 0;

            if (websocket) {
                isIntentionalClose = true;
                websocket.close();
            }

            setTimeout(() => {
                isIntentionalClose = false;
                connectWebSocket();
            }, 100);
        }

        // 텍스트 추가
        function addTranscript(text) {
            if (transcriptCount === 0) {
                transcriptionText.innerHTML = '';
            }

            const timestamp = new Date().toLocaleTimeString('ko-KR');
            const item = document.createElement('div');
            item.className = 'transcript-item';
            item.innerHTML = `
                <div class="transcript-time">${timestamp}</div>
                <div class="transcript-text">${text}</div>
            `;
            transcriptionText.appendChild(item);
            transcriptionText.scrollTop = transcriptionText.scrollHeight;

            transcriptCount++;
            textCount.textContent = transcriptCount;
        }

        // 키워드 추가
        function addKeywords(keywords) {
            if (keywordMap.size === 0) {
                keywordsContainer.innerHTML = '';
            }

            keywords.forEach(kw => {
                const key = kw.keyword;
                if (keywordMap.has(key)) {
                    const existing = keywordMap.get(key);
                    existing.count++;
                    existing.importance = Math.max(existing.importance, kw.importance);
                    keywordMap.set(key, existing);
                } else {
                    keywordMap.set(key, {
                        keyword: key,
                        importance: kw.importance,
                        count: 1
                    });
                }
            });

            // 키워드 재렌더링
            keywordsContainer.innerHTML = '';
            const sortedKeywords = Array.from(keywordMap.values()).sort((a, b) => b.importance - a.importance);

            sortedKeywords.forEach(kw => {
                const item = document.createElement('div');
                item.className = 'keyword-item';
                item.innerHTML = `
                    <span class="keyword-text">${kw.keyword}</span>
                    <span class="keyword-score">${(kw.importance * 100).toFixed(0)}%</span>
                    ${kw.count > 1 ? `<span class="keyword-count">×${kw.count}</span>` : ''}
                `;
                keywordsContainer.appendChild(item);
            });

            keywordCount.textContent = keywordMap.size;
        }

        // 오디오 시각화
        function visualizeAudio(dataArray) {
            const bars = audioVisualizer.querySelectorAll('.audio-bar');
            const step = Math.floor(dataArray.length / bars.length);

            bars.forEach((bar, i) => {
                const value = dataArray[i * step] || 0;
                const height = Math.max(5, (value / 255) * 40);
                bar.style.height = `${height}px`;
            });
        }

        // 녹음 시작/중지
        async function toggleRecording() {
            if (!isRecording) {
                // WebSocket 연결 확인
                if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                    debugLog('WebSocket not connected, attempting to reconnect...');
                    alert('서버 연결이 끊어졌습니다. 재연결을 시도합니다...');
                    reconnectWebSocket();
                    return;
                }

                try {
                    debugLog('Requesting microphone access...');
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            channelCount: 1,
                            sampleRate: 16000,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });

                    debugLog('Microphone access granted');
                    audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                    source = audioContext.createMediaStreamSource(stream);

                    const bufferSize = 2048;
                    processor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                    // 오디오 분석기
                    const analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    const dataArray = new Uint8Array(analyser.frequencyBinCount);

                    source.connect(analyser);
                    source.connect(processor);
                    processor.connect(audioContext.destination);

                    // 시각화
                    const visualize = () => {
                        if (isRecording) {
                            analyser.getByteFrequencyData(dataArray);
                            visualizeAudio(dataArray);
                            requestAnimationFrame(visualize);
                        }
                    };
                    visualize();

                    // 오디오 처리
                    processor.onaudioprocess = (e) => {
                        if (!isRecording) return;

                        const inputData = e.inputBuffer.getChannelData(0);

                        // Convert Float32Array to base64 - always send, no level check
                        const buffer = new ArrayBuffer(inputData.length * 4);
                        const view = new Float32Array(buffer);
                        view.set(inputData);

                        // Fixed base64 encoding - avoid String.fromCharCode on large arrays
                        const bytes = new Uint8Array(buffer);
                        let binary = '';
                        const chunkSize = 8192;
                        for (let i = 0; i < bytes.length; i += chunkSize) {
                            const chunk = bytes.slice(i, i + chunkSize);
                            binary += String.fromCharCode.apply(null, chunk);
                        }
                        const base64 = btoa(binary);

                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            websocket.send(JSON.stringify({
                                type: 'audio',
                                data: base64
                            }));
                            packetsSent++;
                            packetCount.textContent = packetsSent;

                            const sum = inputData.reduce((acc, val) => acc + Math.abs(val), 0);
                            const avgLevel = sum / inputData.length;

                            if (packetsSent % 10 === 0) {
                                debugLog(`Sent ${packetsSent} audio packets, avg level: ${avgLevel.toFixed(4)}`);
                            }
                        } else {
                            debugLog('WebSocket not ready, skipping audio packet');
                        }
                    };

                    isRecording = true;
                    recordButton.textContent = '⏹️ 녹음 중지';
                    recordButton.classList.add('recording');

                    recordingStartTime = Date.now();
                    recordingTimer = setInterval(updateRecordTime, 1000);
                    debugLog('Recording started');

                } catch (error) {
                    debugLog(`Microphone access error: ${error}`);
                    alert('마이크 접근 권한이 필요합니다.');
                }
            } else {
                debugLog('Stopping recording...');

                if (processor) {
                    processor.disconnect();
                }
                if (source) {
                    source.disconnect();
                }
                if (audioContext) {
                    audioContext.close();
                }

                isRecording = false;
                recordButton.textContent = '🎤 녹음 시작';
                recordButton.classList.remove('recording');

                if (recordingTimer) {
                    clearInterval(recordingTimer);
                    recordingTimer = null;
                }

                const bars = audioVisualizer.querySelectorAll('.audio-bar');
                bars.forEach(bar => bar.style.height = '5px');

                debugLog(`Recording stopped. Total packets sent: ${packetsSent}`);
                packetsSent = 0;
            }
        }

        recordButton.addEventListener('click', toggleRecording);

        // API 상태 확인
        debugLog('Checking API status...');
        fetch('/api/config')
            .then(response => response.json())
            .then(data => {
                debugLog(`API config received: ${JSON.stringify(data)}`);
                if (data.gpu) {
                    deviceStatus.textContent = '✅ GPU 준비';
                    deviceStatus.classList.add('active');
                }
                if (data.llm_enabled) {
                    llmStatus.textContent = '✅ LLM 준비';
                    llmStatus.classList.add('active');
                }
            })
            .catch(err => debugLog(`API config error: ${err}`));

        // 초기화 함수들
        window.clearTranscripts = function() {
            transcriptCount = 0;
            textCount.textContent = '0';
            transcriptionText.innerHTML = '<div class="no-keywords">녹음 버튼을 눌러 시작하세요...</div>';
            debugLog('Transcripts cleared');
        }

        window.clearKeywords = function() {
            keywordMap.clear();
            keywordCount.textContent = '0';
            keywordsContainer.innerHTML = '<div class="no-keywords">키워드가 여기에 표시됩니다</div>';
            debugLog('Keywords cleared');
        }

        // 페이지 언로드 시 WebSocket 정리
        window.addEventListener('beforeunload', () => {
            isIntentionalClose = true;
            if (websocket) {
                websocket.close();
            }
        });

        // WebSocket 연결 시작
        connectWebSocket();

        }); // DOMContentLoaded 끝
    </script>
</body>
</html>